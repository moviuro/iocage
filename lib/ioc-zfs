#!/bin/sh

# activate pool for iocage
# intended for automation tool
__activate () {
    local _pool

    _pool=${1}

    __set_dataset_ioc_prop active=yes ${_pool}
}

__deactivate () {
    local _pool

    _pool=${1}

    __unset_dataset_ioc_prop active ${_pool}
}

__create_basejail () {
    local _release _jail_arch _bfs_list _fs

    _release=${1}
    _jail_arch=$(__get_default_prop arch)

    eval _bfs_list='$bfs_list_'${_jail_arch}

    __stderr -n "  INFO: Creating basejail ZFS datasets..."

    for _fs in ${_bfs_list} ; do
        zfs create -o compression=lz4 -p \
            ${pool}/iocage/base/${_release}/root/${_fs}
    done

    __stderr -e " ${OK}"
}

__reclone_basejail () {
    local _dataset _fulluuid _jail_release _jail_arch _bfs_list _fs

    _dataset=${1}

    _fulluuid=$(__get_dataset_ioc_prop host_hostuuid ${_dataset})
    _jail_release=$(__get_dataset_ioc_prop release ${_dataset})
    _jail_arch=$(__get_dataset_ioc_prop arch ${_dataset})

    eval _bfs_list='$bfs_list_'${_jail_arch}

    __stderr "[${_fulluuid}] Re-creating base snapshot"

    zfs destroy -rRf ${pool}/iocage/base@${_fulluuid} 2>/dev/null
    zfs snapshot -r  ${pool}/iocage/base@${_fulluuid} 2>/dev/null

    __stderr -e "[${_fulluuid}] Re-creating base snapshot ${OK}"
    __stderr "[${_fulluuid}] Re-cloning base filesystems"

    # Re-clone required filesystems
    for _fs in ${_bfs_list} ; do
        zfs destroy -f ${_dataset}/root/${_fs} 2>/dev/null
        zfs clone \
            ${pool}/iocage/base/${_jail_release}/root/${_fs}@${_fulluuid} \
            ${_dataset}/root/${_fs}
    done

    __stderr -e "[${_fulluuid}] Re-cloning base filesystems ${OK}"
}

# This creates jails ---------------------------------------------------
__create_jail () {
    local _flag _dataset _fs_list _zfsconfig _fs _dir _jail_arch _bfs_list

    zfs list -r ${pool}/iocage/releases | grep -q ${release} ||
        __fatal_error "Release ${release} not found locally, run fetch first."

    _flag=${1}

    _dataset=${pool}/iocage/jails/${uuid}

    case "${_flag}" in
        # Create a cloned jail.
        -c)
            _fs_list=$(zfs list -rHo name ${pool}/iocage/releases/${release})
            _zfsconfig=$(__configure_jail generate) ||
                __fatal_error "A problem occurred while configuring the jail."

            zfs snapshot -r ${pool}/iocage/releases/${release}@${uuid}

            for _fs in ${_fs_list} ; do
                _cfs=$(echo ${_fs} \
                       | sed s#/releases/${release}#/jails/${uuid}#g)
                eval "zfs clone ${_zfsconfig} ${_fs}@${uuid} ${_cfs}"
            done
            ;;

        # Create an empty jail.
        -e)
            _zfsconfig=$(__configure_jail generate) ||
                __fatal_error "A problem occurred while configuring the jail."

            eval "zfs create -p ${_zfsconfig} ${_dataset}"
            zfs create -p ${_dataset}/root
            ;;

        # Create a basejail.
        -b)
            export type="basejail"
            _jail_arch=$(__get_default_prop arch)

            eval _bfs_list='$bfs_list_'${_jail_arch}

            _zfsconfig=$(__configure_jail generate) ||
                __fatal_error "A problem occurred while configuring the jail."

            zfs snapshot -r ${pool}/iocage/base@${uuid}
            eval "zfs create -p ${_zfsconfig} ${_dataset}"
            zfs create -o compression=lz4 -p ${_dataset}/root/usr

            for _fs in ${_bfs_list} ; do
                zfs clone -o compression=lz4 -o readonly=on \
                    ${pool}/iocage/base/${release}/root/${_fs}@${uuid} \
                    ${_dataset}/root/${_fs}
            done

            for _dir in ${bdir_list} ; do
                cp -a ${iocroot}/base/${release}/root/${_dir} \
                   ${iocroot}/jails/${uuid}/root/${_dir}
            done
            ;;

        # Create a standard jail.
        *)
            zfs snapshot -r ${pool}/iocage/releases/${release}@${uuid}
            zfs send     -R ${pool}/iocage/releases/${release}@${uuid} \
            | zfs recv      ${_dataset}
            zfs destroy  -r ${pool}/iocage/releases/${release}@${uuid}
            zfs destroy  -r ${_dataset}@${uuid}

            __configure_jail ${_dataset}
            ;;
    esac

    touch ${iocroot}/jails/${uuid}/fstab

    # Remove any clone snapshots carried over from the RELEASE datasets.
    __snapremove ${_dataset} ALL

    # Write the default rc.conf to the jail, except for empty jails.
    if [ "${_flag}" != "-e" ] ; then
        echo "hostname=\"${hostname}\"" \
        > ${iocroot}/jails/${uuid}/root/etc/rc.conf

        __jail_rc_conf >> ${iocroot}/jails/${uuid}/root/etc/rc.conf

        __resolv_conf ${_dataset}
    else
        echo ${uuid}
    fi

    zfs create -o compression=lz4 ${pool}/${jail_zfs_dataset}
    zfs set mountpoint=none ${pool}/${jail_zfs_dataset}
    zfs set jailed=on ${pool}/${jail_zfs_dataset}

    __update_mountpoint ${_dataset}

    # Install extra packages.
    # This requires working resolv.conf in jail
    if [ "${pkglist}" != "none" ] ; then
        __pkg_install "${iocroot}/jails/${uuid}/root"
    fi
}

# Cloning jails ----------------------------------------------------------
__clone_jail () {
    local _switches _dataset _snapshot _zfsconfig _fs_list _fs _cfs \
          _clone_dataset _mountpoint

    _switches=${1} # {keep props}{keep fstab}
    _dataset=${2}
    _snapshot=${3:-@${uuid}}

    # Get the configuration for this jail, either from defaults or the source.
    # _switches: {keep props?}{don't care}
    case ${_switches} in
        # Use properties from the defaults.
        0?) _zfsconfig=$(__configure_jail generate) ;;
        1?) _zfsconfig=$(__configure_jail generate ${_dataset}) ;;
    esac ||
        __fatal_error "A problem occurred while configuring the jail."

    _fs_list=$(zfs list -rHo name ${_dataset})

    if ! zfs list ${_dataset}${_snapshot} >&- 2>&- ; then
        zfs snapshot -r ${_dataset}${_snapshot}
    fi

    for _fs in ${_fs_list} ; do
        _cfs=$(echo ${_fs} | sed s#${_dataset}#${pool}/iocage/jails/${uuid}#g)
        if echo ${_cfs} | grep -q data$ ; then
            zfs clone -o mountpoint=none -o jailed=on ${_fs}${_snapshot} ${_cfs}
        else
            eval "zfs clone ${_zfsconfig} ${_fs}${_snapshot} ${_cfs}"
        fi
    done

    _clone_dataset=${pool}/iocage/jails/${uuid}

    __update_mountpoint ${_clone_dataset}
    _mountpoint=$(__get_dataset_zfs_prop mountpoint ${_clone_dataset})

    # Optionally keep the fstab file in place, if asked to.
    # _switches: {don't care}{keep fstab}
    case ${_switches} in
        # Not asked to keep fstab. Make a backup and create a new blank fstab.
        ?0)
            mv ${_mountpoint}/fstab ${_mountpoint}/fstab.${uuid}
            touch ${_mountpoint}/fstab
            ;;
    esac

    # Update hostname in the clone's rc.conf to the new UUID.
    sed -E -e "s/[a-zA-Z0-9]{8,}-.*-.*-.*-[a-zA-Z0-9]{12,}/${uuid}/g" \
        -i '' ${_mountpoint}/root/etc/rc.conf
}

# Destroy jails --------------------------------------------------------------
__destroy_jail () {
    local _dataset _force _fulluuid _tag _origin _jail_type

    _dataset=${1}
    _force=${2}

    if [ ${_dataset} = ${pool}/iocage/.defaults ] ; then
        __info "Destroying user defaults"
        zfs destroy -fr ${_dataset}
        return
    fi

    _fulluuid=$(__get_dataset_ioc_prop host_hostuuid ${_dataset})
    if __is_running ${_fulluuid} ; then
        if [ "${_force}" -eq 1 ] ; then
            __stop_jail ${_dataset}
        else
            __fatal_error "Jail is still up and running (use -f to force)!"
        fi
    fi

    _tag=$(__get_dataset_ioc_prop tag ${_dataset})
    _origin=$(__get_dataset_zfs_prop origin ${_dataset})
    _jail_type=$(__get_dataset_ioc_prop type ${_dataset})

    __info "Destroying ${_fulluuid} (${_tag})"

    __unlink_tag ${_dataset}
    zfs destroy -fr ${_dataset}

    if [ "${_origin}" != "-" ] ; then
        __info "Destroying clone origin ${_origin}"
        zfs destroy -r ${_origin}
    fi

    if [ "${_jail_type}" == "basejail" ] ; then
        __info "Destroying base snapshot @{_fulluuid}"
        zfs destroy -fr ${pool}/iocage/base@${_fulluuid}
    fi
}

__destroy_all () {
    local _force _jails _jail

    _force=${1}

    _jails=$(__find_jail ALL)

    __info "Destroying all jails"

    for _jail in ${_jails} ; do
        __destroy_jail ${_jail} ${_force}
    done

    rm -f ${iocroot}/tags/*
}

# Destroy ${pool}/iocage. Any running iocage jails are stopped first.
__clean_all () {
    local _running _uuid

    # Get a list of all running iocage jails.
    _running=$(jls name | awk '/^ioc-/ { sub(/^ioc-/, "", $1); print $1 }')

    # Stop them all in parallel.
    for _uuid in ${_running} ; do
        __stop_jail ${pool}/iocage/jails/${_uuid} &
    done

    # Wait for all the jails to be stopped.
    wait

    # Destroy the iocage dataset.
    __info "Destroying ${pool}/iocage"
    zfs destroy -rRf ${pool}/iocage
}

# Destroy ${pool}/iocage/releases and ${pool}/iocage/base. Any running iocage
# jails that are cloned from either of these datasets are stopped first.
__clean_releases () {
    local _running _clones _uuid

    #
    # Stop all running iocage jails that are clones of a release.
    #

    # Create a regex for matching the running iocage jails. The resulting
    # string will have an extra | at the end which will need to be removed.
    _running=$(jls name \
               | awk '/^ioc-/ { sub(/^ioc-/, "", $1); printf "%s|", $1 }')

    # Create a list of running clones by listing jail datasets alongside their
    # origin and matching the origin against the datasets to be removed as well
    # as the UUID against the running jails. To match basejails this way
    # requires the list depth to be set to 3, so we reduce the output to
    # unique datasets by splitting the dataset name into parts and only
    # printing the UUID portion, then piping through uniq.
    _clones=$(zfs list -Hrd3 -o name,origin ${pool}/iocage/jails \
              | awk -v origins="^${pool}/iocage/(releases|base)/" \
                    -v running="${_running%|}" \
                    '$2 ~ origins && $1 ~ running {
                       split($1, name, "/");
                       print name[4];
                     }' \
              | uniq)

    # Stop running jails in parallel.
    for _uuid in ${_clones} ; do
        __stop_jail ${pool}/iocage/jails/${_uuid} &
    done

    # Wait for the jails to be stopped.
    wait

    #
    # Destroy the releases and the bases created from them.
    #

    __info "Destroying ${pool}/iocage/base"
    zfs destroy -rRf ${pool}/iocage/base

    __info "Destroying ${pool}/iocage/downloaded"
    zfs destroy -rRf ${pool}/iocage/download

    __info "Destroying ${pool}/iocage/releases"
    zfs destroy -rRf ${pool}/iocage/releases
}

# Destroy ${pool}/iocage/jails. Any running jails are stopped first.
__clean_jails () {
    local _running _uuid

    # Get a list of all running iocage jails.
    _running=$(jls name | awk '/^ioc-/ { sub(/^ioc-/, "", $1); print $1 }')

    # Stop them all in parallel.
    for _uuid in ${_running} ; do
        __stop_jail ${pool}/iocage/jails/${_uuid} &
    done

    # Wait for all the jails to be stopped.
    wait

    # Destroy the jails dataset.
    __info "Destroying ${pool}/iocage/jails"
    zfs destroy -rRf ${pool}/iocage/jails

    # Remove all the tag symlinks.
    __info "Removing symlinks in ${iocroot}/tags"
    rm -f ${iocroot}/tags/*
}

# check if our datasets exist, if not create them
# fixes https://github.com/iocage/iocage/issues/80
__check_filesystems () {
    local _missing _filesystems _fs

    _missing=0
    _filesystems="${iocroot}
                  ${iocroot}/jails
                  ${iocroot}/.defaults
                  ${iocroot}/download
                  ${iocroot}/releases"

    for _fs in ${_filesystems} ; do
        zfs get -H creation ${pool}${_fs} > /dev/null 2>&1
        if [ ${?} -ne 0 ] ; then
            _missing=1
            __info "Creating ${pool}${_fs}"
            __require_root \
                "Please run iocage as root to create missing datasets."
            zfs create -p ${pool}${_fs}
            zfs set mountpoint=${_fs} ${pool}${_fs}
            if [ ${_fs} == ${iocroot}/.defaults ] ; then
                __update_defaults_ioc_properties
            fi
        fi
    done

    if [ ${_missing} -gt 0 ] ; then
        zfs mount -a
    fi

    if [ ! -d ${iocroot}/tags ] ; then
        __info "Creating ${iocroot}/tags"
        __require_root \
            "Please run iocage as root to create missing directories."
        mkdir -p ${iocroot}/tags
    fi
}

# Check that all our jails are compatible with this version of iocage.
#
# If a jail isn't compatible, make it compatible.
#
# Version is stored per-jail so that when jails are transferred between
# different versions of iocage, we can detect and fix missing properties without
# requiring manual intervention.
__check_all_ioc_version () {
    local _mismatches _jail _uuid

    # This is only slightly complicated because the version string contains
    # parenthesis which must be escaped. Here's the play-by-play:
    #
    # Find the dataset and the iocage version for each jail with a recursive
    # zfs list and pipe it to our best friend, awk.
    #
    # Start awk by setting the variable version="${iocage_version}", then do a
    # global string substitution in the BEGIN action to escape the parenthesis
    # around the date in the version string.
    #
    # The first line of input to awk will be ${pool}${iocroot}/jails because of
    # how zfs lists datasets recursively, so we skip that line with FNR > 1.
    #
    # If the line doesn't contain our version string, print the first field,
    # which gives us the dataset with a mismatched version.
    _mismatches=$(zfs get -Hrd1 -o name,value \
                      org.freebsd.iocage:iocage_version \
                      ${pool}${iocroot}/jails \
                         | awk -v version="${iocage_version}" \
                               'BEGIN { gsub(/[()]/, "\\\\&", version) }
                                FNR > 1 && $0 !~ version { print $1 }')

    for _jail in ${_mismatches} ; do
        __update_dataset_ioc_properties ${_jail} &
    done

    wait
}

# Check that our jail is compatible with this version of iocage.
#
# If the jail isn't compatible, make it compatible.
#
# Version is stored per-jail so that when jails are transferred between
# different versions of iocage, we can detect and fix missing properties without
# requiring manual intervention.
__check_dataset_ioc_version () {
    local _dataset _jail_version _uuid

    _dataset=${1}

    _jail_version=$(__get_dataset_ioc_prop iocage_version ${_dataset})

    if [ "${_jail_version}" != "${iocage_version}" ] ; then
        __update_dataset_ioc_properties ${_jail}
    fi
}

# Same as above but for the .defaults dataset.
__check_defaults_ioc_version () {
    local _dataset _jail_version _uuid

    _dataset=${pool}/iocage/.defaults

    _jail_version=$(__get_dataset_ioc_prop iocage_version ${_dataset})

    if [ "${_jail_version}" != "${iocage_version}" ] ; then
        __info "Updating default iocage properties."
        __require_root \
            "Please run iocage as root to update default iocage properties."
        __update_defaults_ioc_properties
    fi
}

# Add missing ioc properties to the .defaults dataset.
#
# When iocage is updated and new properties are added, these properties
# will be missing from existing jails. This function looks for any unset
# properties on the default dataset and sets them to the hardcoded default.
__update_defaults_ioc_properties () {
    local _dataset _CONF _prop _value

    _dataset=${pool}/iocage/.defaults

    _CONF="${CONF_RCTL}
           ${CONF_NET}
           ${CONF_JAIL}
           ${CONF_CUSTOM}
           ${CONF_SYNC}
           ${CONF_FTP}"

    for _prop in ${_CONF} ; do
        _value=$(__get_dataset_ioc_prop ${_prop} ${_dataset})
        if [ "${_value}" == "-" ] ; then
            eval _value=\$${_prop}
            __set_dataset_ioc_prop ${_prop}="${_value}" ${_dataset}
        fi
    done

    __set_dataset_ioc_prop iocage_version="${iocage_version}" ${_dataset}
}

# Add missing ioc properties to an existing jail dataset.
#
# When iocage is updated and new properties are added, these properties
# will be missing from existing jails. This function looks for any unset
# properties and sets them to the default value.
__update_dataset_ioc_properties () {
    local _dataset _uuid _CONF _prop _value

    _dataset=${1}

    _uuid=$(__get_dataset_ioc_prop host_hostuuid ${_dataset})
    __info "Updating iocage properties for ${_uuid}"

    _CONF="${CONF_RCTL}
           ${CONF_NET}
           ${CONF_JAIL}
           ${CONF_CUSTOM}
           ${CONF_SYNC}
           ${CONF_FTP}"

    for _prop in ${_CONF} ; do
        _value=$(__get_dataset_ioc_prop ${_prop} ${_dataset})
        if [ "${_value}" == "-" ] ; then
            _value=$(__get_default_prop ${_prop})
            __set_dataset_ioc_prop ${_prop}="${_value}" ${_dataset}
        fi
    done

    __set_dataset_ioc_prop iocage_version="${iocage_version}" ${_dataset}
}

# Unset a property by inheriting from the parent dataset.
__unset_dataset_zfs_prop () {
    local _property _dataset

    _property=${1}
    _dataset=${2}

    zfs inherit ${_property} ${_dataset}
}

__unset_dataset_ioc_prop () {
    local _property _dataset

    _property=${1}
    _dataset=${2}

    zfs inherit org.freebsd.iocage:${_property} ${_dataset}
}
